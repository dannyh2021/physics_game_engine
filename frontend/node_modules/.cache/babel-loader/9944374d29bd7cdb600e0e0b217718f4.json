{"ast":null,"code":"// shaders works\nconst VERTEX_SHADER_SOURCE = `#version 300 es\n\nvoid main() {\n    gl_Position = vec4(0.5, 0.0, 0.0, 1.0);\n    gl_PointSize = 10.0;\n}\n`;\nconst FRAGMENT_SHADER_SOURCE = `#version 300 es\n\nprecision highp float;\n\nout vec4 fragColor;\nvoid main() {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n`; // shaders for testing\n\nconst VERTEX_SHADER_2_SOURCE = `#version 300 es\n\n// an attribute is an input(in) to a vertex shader.\n// It will receive data from a buffer.\nin vec4 a_position;\nvoid main() {\n    gl_Position = a_position;\n    gl_PointSize = 10.0;\n}\n`;\nexport class GraphicsEngine {\n  constructor(gl) {\n    this.gl = gl;\n    this.g_points = [];\n  }\n\n  print() {\n    console.log(\"graphics engine print\", this.gl);\n  }\n\n  draw() {\n    const gl = this.gl;\n    let vertexShader = compileShader(gl, VERTEX_SHADER_2_SOURCE, gl.VERTEX_SHADER);\n    let fragmentShader = compileShader(gl, FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);\n    let program = createProgram(gl, vertexShader, fragmentShader); // Tell WebGL to use our program\n\n    gl.useProgram(program);\n    let positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n\n    if (positionAttributeLocation < 0) {\n      console.log(\"Failed to get the storage location of a_position\");\n      return;\n    } // Pass the vertex position to attribute variable\n\n\n    gl.vertexAttrib3f(positionAttributeLocation, 0.5, 0.0, 0.0); // Set the color for clearing <canvas> and clear <canvas>\n\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT); // Draw a point\n\n    gl.drawArrays(gl.POINTS, 0, 1);\n  }\n\n  click(e, gl, canvas, a_position) {\n    console.log(\"mouse clicked\");\n    let x = e.clientX; // x coordinate of a mouse pointer\n\n    let y = e.clientY;\n    let rect = e.target.getBoundingClientRect();\n    x = (x - rect.left - canvas.height / 2) / (canvas.height / 2);\n    y = (canvas.width / 2 - (y - rect.top)) / (canvas.width / 2);\n    console.log(\"x\", x, \"y\", y, \"rect\", rect); // Store the coordinates into g_points array\n\n    this.g_points.push(x);\n    this.g_points.push(y);\n  }\n\n}\n/**\n * Creates and compiles a shader.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {string} shaderSource The GLSL source code for the shader.\n * @param {number} shaderType The type of shader, VERTEX_SHADER or FRAGMENT_SHADER.\n * @return {!WebGLShader} The shader.\n */\n\nfunction compileShader(gl, shaderSource, shaderType) {\n  // Create the shader object\n  let shader = gl.createShader(shaderType); // Set the shader source code.\n\n  gl.shaderSource(shader, shaderSource); // Compile the shader\n\n  gl.compileShader(shader); // Check if it compiled\n\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (!success) {\n    // Something went wrong during compilation; get the error\n    throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n  }\n\n  return shader;\n}\n/** \n * Creates a program from 2 shaders.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {!WebGLShader} vertexShader A vertex shader.\n * @param {!WebGLShader} fragmentShader A fragment shader.\n * @return {!WebGLProgram} A program.\n */\n\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  // create a program.\n  let program = gl.createProgram(); // attach the shaders.\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader); // link the program.\n\n  gl.linkProgram(program); // Check if it linked.\n\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!success) {\n    // something went wrong with the link\n    throw \"program failed to link\" + gl.getProgramInfoLog(program);\n  }\n\n  return program;\n}","map":{"version":3,"names":["VERTEX_SHADER_SOURCE","FRAGMENT_SHADER_SOURCE","VERTEX_SHADER_2_SOURCE","GraphicsEngine","constructor","gl","g_points","print","console","log","draw","vertexShader","compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","useProgram","positionAttributeLocation","getAttribLocation","vertexAttrib3f","clearColor","clear","COLOR_BUFFER_BIT","drawArrays","POINTS","click","e","canvas","a_position","x","clientX","y","clientY","rect","target","getBoundingClientRect","left","height","width","top","push","shaderSource","shaderType","shader","createShader","success","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog"],"sources":["/Users/danny/Github/physics_game_engine/frontend/src/graphics_engine/GraphicsEngine.ts"],"sourcesContent":["// shaders works\nconst VERTEX_SHADER_SOURCE =\n`#version 300 es\n\nvoid main() {\n    gl_Position = vec4(0.5, 0.0, 0.0, 1.0);\n    gl_PointSize = 10.0;\n}\n`;\n\nconst FRAGMENT_SHADER_SOURCE =\n`#version 300 es\n\nprecision highp float;\n\nout vec4 fragColor;\nvoid main() {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n`;\n\n// shaders for testing\nconst VERTEX_SHADER_2_SOURCE =\n`#version 300 es\n\n// an attribute is an input(in) to a vertex shader.\n// It will receive data from a buffer.\nin vec4 a_position;\nvoid main() {\n    gl_Position = a_position;\n    gl_PointSize = 10.0;\n}\n`;\n\nexport class GraphicsEngine {\n    private g_points = [];\n    constructor(private gl: WebGL2RenderingContext) {}\n\n    print(): void {\n        console.log(\"graphics engine print\", this.gl);\n    }\n\n    draw(): void {\n        const gl = this.gl\n\n        let vertexShader = compileShader(gl, VERTEX_SHADER_2_SOURCE, gl.VERTEX_SHADER);\n        let fragmentShader = compileShader(gl, FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);\n        let program = createProgram(gl, vertexShader, fragmentShader);\n\n        // Tell WebGL to use our program\n        gl.useProgram(program);\n\n        let positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n        if (positionAttributeLocation < 0) {\n            console.log(\"Failed to get the storage location of a_position\");\n            return;\n        }\n\n        // Pass the vertex position to attribute variable\n        gl.vertexAttrib3f(positionAttributeLocation, 0.5, 0.0, 0.0);\n        \n        // Set the color for clearing <canvas> and clear <canvas>\n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        // Draw a point\n        gl.drawArrays(gl.POINTS, 0, 1);\n    }\n\n    click(e: MouseEvent, gl: WebGL2RenderingContext, canvas: HTMLCanvasElement, a_position: number): void {\n        console.log(\"mouse clicked\");\n        let x = e.clientX; // x coordinate of a mouse pointer\n        let y = e.clientY;\n        let rect = (e.target as HTMLElement).getBoundingClientRect();\n\n        x = ((x - rect.left) - canvas.height/2)/(canvas.height/2);\n        y = (canvas.width/2 - (y - rect.top))/(canvas.width/2);\n        console.log(\"x\", x, \"y\", y, \"rect\", rect);\n\n        // Store the coordinates into g_points array\n        this.g_points.push(x); this.g_points.push(y);\n    }\n}\n\n/**\n * Creates and compiles a shader.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {string} shaderSource The GLSL source code for the shader.\n * @param {number} shaderType The type of shader, VERTEX_SHADER or FRAGMENT_SHADER.\n * @return {!WebGLShader} The shader.\n */\nfunction compileShader(gl: WebGL2RenderingContext, shaderSource: string, shaderType: number): WebGLShader {\n    // Create the shader object\n    let shader = gl.createShader(shaderType);\n\n    // Set the shader source code.\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check if it compiled\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!success) {\n        // Something went wrong during compilation; get the error\n        throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n    }\n\n    return shader;\n}\n\n/** \n * Creates a program from 2 shaders.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {!WebGLShader} vertexShader A vertex shader.\n * @param {!WebGLShader} fragmentShader A fragment shader.\n * @return {!WebGLProgram} A program.\n */\nfunction createProgram(gl: WebGL2RenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\n    // create a program.\n    let program = gl.createProgram();\n\n    // attach the shaders.\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n\n    // link the program.\n    gl.linkProgram(program);\n\n    // Check if it linked.\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!success) {\n        // something went wrong with the link\n        throw(\"program failed to link\" + gl.getProgramInfoLog(program));\n    }\n\n    return program;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}