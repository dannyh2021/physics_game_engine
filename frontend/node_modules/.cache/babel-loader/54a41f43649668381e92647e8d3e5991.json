{"ast":null,"code":"// shaders works\nconst VERTEX_SHADER_SOURCE = `#version 300 es\n\n// An attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer.\nin vec4 a_position;\n\n// A matrix to transform the position by\nuniform mat4 u_matrix;\n\nvoid main() {\n    // Multiply the position by the matrix.\n    gl_Position = u_matrix * a_position;\n}\n`;\nconst FRAGMENT_SHADER_SOURCE = `#version 300 es\n\nprecision highp float;\n\nout vec4 fragColor;\nvoid main() {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n`; // shaders for testing\n\nconst VERTEX_SHADER_2_SOURCE = `#version 300 es\n\n// an attribute is an input(in) to a vertex shader.\n// It will receive data from a buffer.\nin vec4 a_position;\nvoid main() {\n    gl_Position = a_position;\n    gl_PointSize = 10.0;\n}\n`;\nexport class GraphicsEngine {\n  constructor(gl) {\n    this.gl = gl;\n    this.g_points = [];\n    this.program = null;\n  }\n\n  print() {\n    console.log(\"graphics engine print\", this.gl);\n  }\n\n  draw() {\n    const gl = this.gl; // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n\n    let size = 3; // 3 components per iteration\n\n    let type = gl.FLOAT; // the data is 32bit floats\n\n    let normalize = false; // don't normalize the data\n\n    let stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position.\n\n    let offset = 0; // start at the beginning of the buffer\n\n    let vertexShader = compileShader(gl, VERTEX_SHADER_2_SOURCE, gl.VERTEX_SHADER);\n    let fragmentShader = compileShader(gl, FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);\n    let program = createProgram(gl, vertexShader, fragmentShader);\n    this.program = program; // Tell WebGL to use our program\n\n    gl.useProgram(program);\n    let positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n\n    if (positionAttributeLocation < 0) {\n      console.log(\"Failed to get the storage location of a_position\");\n      return;\n    } // Fill the current ARRAY_BUFFER buffer\n    // with the values that define a letter 'F'.\n\n\n    setGeometry(gl); // Compute the matrix\n\n    let matrix = projection(100, 100, 100);\n  }\n\n  onClick(e, canvas) {\n    let positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    console.log(\"positionAttributeLocation\", positionAttributeLocation);\n    this.click(e, this.gl, canvas, positionAttributeLocation);\n  }\n\n  click(e, gl, canvas, a_position) {\n    console.log(\"mouse clicked\");\n    let x = e.clientX; // x coordinate of a mouse pointer\n\n    let y = e.clientY;\n    let rect = e.target.getBoundingClientRect();\n    x = (x - rect.left - canvas.width / 2) / (canvas.width / 2);\n    y = (canvas.height / 2 - (y - rect.top)) / (canvas.height / 2);\n    console.log(\"x\", x, \"y\", y, \"rect\", rect); // Store the coordinates into g_points array\n\n    this.g_points.push(x);\n    this.g_points.push(y);\n    console.log(\"g_points\", this.g_points); // Clear <canvas>\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    for (let i = 0; i < this.g_points.length; i += 2) {\n      // Pass the position of a point to a_Position variable\n      gl.vertexAttrib3f(a_position, this.g_points[i], this.g_points[i + 1], 0.0); // Draw a point\n\n      gl.drawArrays(gl.POINTS, 0, 1);\n    }\n  }\n\n}\n/**\n * Creates and compiles a shader.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {string} shaderSource The GLSL source code for the shader.\n * @param {number} shaderType The type of shader, VERTEX_SHADER or FRAGMENT_SHADER.\n * @return {!WebGLShader} The shader.\n */\n\nfunction compileShader(gl, shaderSource, shaderType) {\n  // Create the shader object\n  let shader = gl.createShader(shaderType); // Set the shader source code.\n\n  gl.shaderSource(shader, shaderSource); // Compile the shader\n\n  gl.compileShader(shader); // Check if it compiled\n\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (!success) {\n    // Something went wrong during compilation; get the error\n    throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n  }\n\n  return shader;\n}\n/** \n * Creates a program from 2 shaders.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {!WebGLShader} vertexShader A vertex shader.\n * @param {!WebGLShader} fragmentShader A fragment shader.\n * @return {!WebGLProgram} A program.\n */\n\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  // create a program.\n  let program = gl.createProgram(); // attach the shaders.\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader); // link the program.\n\n  gl.linkProgram(program); // Check if it linked.\n\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!success) {\n    // something went wrong with the link\n    throw \"program failed to link\" + gl.getProgramInfoLog(program);\n  }\n\n  return program;\n} // Fill the current ARRAY_BUFFER buffer\n// with the values that define a letter 'F'.\n\n\nfunction setGeometry(gl) {\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([// left column\n  0, 0, 0, 30, 0, 0, 0, 150, 0, 0, 150, 0, 30, 0, 0, 30, 150, 0, // top rung\n  30, 0, 0, 100, 0, 0, 30, 30, 0, 30, 30, 0, 100, 0, 0, 100, 30, 0, // middle rung\n  30, 60, 0, 67, 60, 0, 30, 90, 0, 30, 90, 0, 67, 60, 0, 67, 90, 0]), gl.STATIC_DRAW);\n}","map":{"version":3,"names":["VERTEX_SHADER_SOURCE","FRAGMENT_SHADER_SOURCE","VERTEX_SHADER_2_SOURCE","GraphicsEngine","constructor","gl","g_points","program","print","console","log","draw","size","type","FLOAT","normalize","stride","offset","vertexShader","compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","useProgram","positionAttributeLocation","getAttribLocation","setGeometry","matrix","projection","onClick","e","canvas","click","a_position","x","clientX","y","clientY","rect","target","getBoundingClientRect","left","width","height","top","push","clear","COLOR_BUFFER_BIT","i","length","vertexAttrib3f","drawArrays","POINTS","shaderSource","shaderType","shader","createShader","success","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","bufferData","ARRAY_BUFFER","Float32Array","STATIC_DRAW"],"sources":["/Users/danny/Github/physics_game_engine/frontend/src/graphics_engine/GraphicsEngine.ts"],"sourcesContent":["import { translation, xRotation } from \"../math_library/Matrix4.ts\";\n\n// shaders works\nconst VERTEX_SHADER_SOURCE =\n`#version 300 es\n\n// An attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer.\nin vec4 a_position;\n\n// A matrix to transform the position by\nuniform mat4 u_matrix;\n\nvoid main() {\n    // Multiply the position by the matrix.\n    gl_Position = u_matrix * a_position;\n}\n`;\n\nconst FRAGMENT_SHADER_SOURCE =\n`#version 300 es\n\nprecision highp float;\n\nout vec4 fragColor;\nvoid main() {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n`;\n\n// shaders for testing\nconst VERTEX_SHADER_2_SOURCE =\n`#version 300 es\n\n// an attribute is an input(in) to a vertex shader.\n// It will receive data from a buffer.\nin vec4 a_position;\nvoid main() {\n    gl_Position = a_position;\n    gl_PointSize = 10.0;\n}\n`;\n\nexport class GraphicsEngine {\n    private g_points = [];\n    private program = null;\n    constructor(private gl: WebGL2RenderingContext) {}\n\n    print(): void {\n        console.log(\"graphics engine print\", this.gl);\n    }\n\n    draw(): void {\n        const gl = this.gl\n\n        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n        let size = 3;           // 3 components per iteration\n        let type = gl.FLOAT;    // the data is 32bit floats\n        let normalize = false;  // don't normalize the data\n        let stride = 0;         // 0 = move forward size * sizeof(type) each iteration to get the next position.\n        let offset = 0;         // start at the beginning of the buffer\n\n        let vertexShader = compileShader(gl, VERTEX_SHADER_2_SOURCE, gl.VERTEX_SHADER);\n        let fragmentShader = compileShader(gl, FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);\n        let program = createProgram(gl, vertexShader, fragmentShader);\n        this.program = program;\n\n        // Tell WebGL to use our program\n        gl.useProgram(program);\n\n        let positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n        if (positionAttributeLocation < 0) {\n            console.log(\"Failed to get the storage location of a_position\");\n            return;\n        }\n\n        // Fill the current ARRAY_BUFFER buffer\n        // with the values that define a letter 'F'.\n        setGeometry(gl);\n        \n        // Compute the matrix\n        let matrix = projection(100, 100, 100);\n        \n    }\n\n    onClick(e: MouseEvent, canvas: HTMLCanvasElement) {\n        let positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n        console.log(\"positionAttributeLocation\", positionAttributeLocation);\n        this.click(e, this.gl, canvas, positionAttributeLocation);\n    }\n\n    click(e: MouseEvent, gl: WebGL2RenderingContext, canvas: HTMLCanvasElement, a_position: number): void {\n        console.log(\"mouse clicked\");\n        let x = e.clientX; // x coordinate of a mouse pointer\n        let y = e.clientY;\n        let rect = (e.target as HTMLElement).getBoundingClientRect();\n\n        x = ((x - rect.left) - canvas.width/2)/(canvas.width/2);\n        y = (canvas.height/2 - (y - rect.top))/(canvas.height/2);\n        console.log(\"x\", x, \"y\", y, \"rect\", rect);\n\n        // Store the coordinates into g_points array\n        this.g_points.push(x); this.g_points.push(y);\n\n        console.log(\"g_points\", this.g_points);\n\n        // Clear <canvas>\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        for(let i = 0; i < this.g_points.length; i += 2) {\n            // Pass the position of a point to a_Position variable\n            gl.vertexAttrib3f(a_position, this.g_points[i], this.g_points[i+1], 0.0);\n\n            // Draw a point\n            gl.drawArrays(gl.POINTS, 0, 1);\n        }\n    }\n}\n\n/**\n * Creates and compiles a shader.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {string} shaderSource The GLSL source code for the shader.\n * @param {number} shaderType The type of shader, VERTEX_SHADER or FRAGMENT_SHADER.\n * @return {!WebGLShader} The shader.\n */\nfunction compileShader(gl: WebGL2RenderingContext, shaderSource: string, shaderType: number): WebGLShader {\n    // Create the shader object\n    let shader = gl.createShader(shaderType);\n\n    // Set the shader source code.\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check if it compiled\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!success) {\n        // Something went wrong during compilation; get the error\n        throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n    }\n\n    return shader;\n}\n\n/** \n * Creates a program from 2 shaders.\n * \n * @param {!WebGL2RenderingContext} gl The WebGL context.\n * @param {!WebGLShader} vertexShader A vertex shader.\n * @param {!WebGLShader} fragmentShader A fragment shader.\n * @return {!WebGLProgram} A program.\n */\nfunction createProgram(gl: WebGL2RenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\n    // create a program.\n    let program = gl.createProgram();\n\n    // attach the shaders.\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n\n    // link the program.\n    gl.linkProgram(program);\n\n    // Check if it linked.\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!success) {\n        // something went wrong with the link\n        throw(\"program failed to link\" + gl.getProgramInfoLog(program));\n    }\n\n    return program;\n}\n\n// Fill the current ARRAY_BUFFER buffer\n// with the values that define a letter 'F'.\nfunction setGeometry(gl) {\n    gl.bufferData(\n        gl.ARRAY_BUFFER, new Float32Array([\n            // left column\n            0, 0, 0,\n            30, 0, 0,\n            0, 150, 0,\n            0, 150, 0,\n            30, 0, 0,\n            30, 150, 0,\n\n            // top rung\n            30, 0, 0,\n            100, 0, 0,\n            30, 30, 0,\n            30, 30, 0,\n            100, 0, 0,\n            100, 30, 0,\n\n            // middle rung\n            30, 60, 0,\n            67, 60, 0,\n            30, 90, 0,\n            30, 90, 0,\n            67, 60, 0,\n            67, 90, 0]),\n        gl.STATIC_DRAW);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}